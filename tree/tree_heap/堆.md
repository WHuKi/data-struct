### 堆

* 堆满足的特点

  * 一个完全二叉树。
  * 堆中每个节点的值都大于等于（小于等于）子树每个节点的值。

* 堆的特性

  * 大顶堆- **arr[i]>=arr[2i+1] && arr[i]>=arr[2i+2]** 每个结点的值都大于或等于其左右孩子结点的值

  * 小顶堆- **arr[i]<=arr[2i+1] && arr[i]<=arr[2i+2]** 每个结点的值都小于或等于其左右孩子结点的值

  * **构建堆都是从堆的最后一个root节点开始也就是(len(arr)-1)/2**

* 举例
  * 参考：https://blog.csdn.net/mofiu/article/details/83620743

  * 例如我们对数组{2,28,6,15,26,22,9,10,18,233,8}进行降序排列

    1、首先构建一个小顶堆，数组默认的图如下

    ![图1](https://img-blog.csdnimg.cn/20181101144527709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

  第一个需要比较的root节点为(len(arr)-1)/2，也就是5节点，因为只有一个子节点，所以只需要比较(2*5+1)节点

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101144611320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

  然后比较（4,9,10）节点比较，先比较9和10节点，选择较小的节点与4节点比较，结果如下图

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2018110114462436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

  然后选择3节点，（3,7,8）节点比较，先比较7和8节点，选择较小的节点与3节点比较，结果如下图

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101144641207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

  接下来比较root节点为2，child为5和6的几个几点。选择5和6中较小的节点与5（root节点）比较，2和5进行交换，交换后不确定5为root（11为子节点）的子节点是否都大于5的值，所以也进行比较一次。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101144701276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

​         接下来对（1,3,4节点比较）较小的节点4与父节点1进行交换

​		 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101144710912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

​			1和4交换后后，4、9、10已经不符合小顶堆的特性了，所以需要重新比较，此时4节点就变成了9和10的root节点

​			![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101144728221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

​			小顶堆构建完成

​			![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101144749154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)

* 排序过程

  * 首先将堆顶的最小值与最后一个值交换（数组中的0和11位置交换），交换后重新构建堆（11位置已经是最小的值，不参与堆的构建，所以重新构建堆的数组要减去最后的值），如此往返，排序就完成了。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/2018110114480194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZml1,size_16,color_FFFFFF,t_70)